Of course. My apologies for the oversight in the previous step. It is a critical failure that would have blocked progress. I will now generate the correct, detailed, and explicit plan for `docs/phases/phase-i-admin-content-curation-dashboard.md`.

This plan covers building the entire "human-in-the-loop" admin interface, from backend API routes to the frontend React components, ensuring that an administrator can review, edit, and publish AI-generated content securely.

---

# **Phase I: Admin Content Curation Dashboard**

**Goal:** Develop the "human-in-the-loop" interface for the content pipeline. This involves building a secure admin dashboard where draft content generated by the AI can be reviewed, edited, and published to the live application.

**Prerequisite:** All previous phases must be complete. The database schema must be in place, and there should be a user in the database who can be manually updated to have the role "ADMIN".

---

### 1. Admin Authorization and API Routes

- [ ] **Task 1.1: Create Admin Authorization Utility:** Create a server-side utility function to verify if the current user is an administrator. This will be reused across all admin-only API routes and pages.

  - **Command:** `mkdir -p src/lib/admin`
  - **File:** `src/lib/admin/auth.ts`
  - **Action:** Create the file with the following complete content.

  ```typescript
  import { createClient } from '@/lib/supabase/server';
  import { prisma } from '@/lib/db';
  import { User } from '@supabase/supabase-js';

  export async function getAdminUser(): Promise<User | null> {
    const supabase = await createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return null;
    }

    const dbUser = await prisma.user.findUnique({
      where: { id: user.id },
      select: { role: true },
    });

    if (dbUser?.role === 'ADMIN') {
      return user;
    }

    return null;
  }
  ```

- [ ] **Task 1.2: Create API Route to Fetch Draft Content:** Implement an admin-only API endpoint to retrieve all episodes currently in "DRAFT" status.

  - **Command:** `mkdir -p src/app/api/admin/drafts`
  - **File:** `src/app/api/admin/drafts/route.ts`
  - **Action:** Create the file with the following complete content.

  ```typescript
  import { NextResponse } from 'next/server';
  import { getAdminUser } from '@/lib/admin/auth';
  import { prisma } from '@/lib/db';

  export async function GET() {
    const adminUser = await getAdminUser();
    if (!adminUser) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    try {
      const drafts = await prisma.episode.findMany({
        where: { status: 'DRAFT' },
        include: {
          summaries: true,
          protocols: true,
        },
        orderBy: {
          publishedAt: 'desc',
        },
      });
      return NextResponse.json(drafts);
    } catch (error) {
      console.error('Error fetching drafts:', error);
      return NextResponse.json(
        { error: 'Failed to fetch draft content' },
        { status: 500 },
      );
    }
  }
  ```

- [ ] **Task 1.3: Create API Route to Update Content:** Implement admin-only `PUT` endpoints to update and publish episodes, protocols, and summaries.

  - **Command:** `mkdir -p src/app/api/admin/episodes/[episodeId] src/app/api/admin/protocols/[protocolId] src/app/api/admin/summaries/[summaryId]`
  - **File 1:** `src/app/api/admin/episodes/[episodeId]/route.ts`
  - **Action 1:** Create the file with a `PUT` handler for episodes.

  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { getAdminUser } from '@/lib/admin/auth';
  import { prisma } from '@/lib/db';

  export async function PUT(
    req: NextRequest,
    { params }: { params: { episodeId: string } },
  ) {
    if (!(await getAdminUser()))
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    try {
      const { title, description, status } = await req.json();
      const updatedEpisode = await prisma.episode.update({
        where: { id: params.episodeId },
        data: { title, description, status },
      });
      return NextResponse.json(updatedEpisode);
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to update episode' },
        { status: 500 },
      );
    }
  }
  ```

  - **File 2:** `src/app/api/admin/protocols/[protocolId]/route.ts`
  - **Action 2:** Create the file with a `PUT` handler for protocols.

  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { getAdminUser } from '@/lib/admin/auth';
  import { prisma } from '@/lib/db';

  export async function PUT(
    req: NextRequest,
    { params }: { params: { protocolId: string } },
  ) {
    if (!(await getAdminUser()))
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    try {
      const {
        name,
        description,
        category,
        implementationGuide,
        isFree,
        status,
      } = await req.json();
      const updatedProtocol = await prisma.protocol.update({
        where: { id: params.protocolId },
        data: {
          name,
          description,
          category,
          implementationGuide,
          isFree,
          status,
        },
      });
      return NextResponse.json(updatedProtocol);
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to update protocol' },
        { status: 500 },
      );
    }
  }
  ```

  - **File 3:** `src/app/api/admin/summaries/[summaryId]/route.ts`
  - **Action 3:** Create the file with a `PUT` handler for summaries.

  ```typescript
  import { NextRequest, NextResponse } from 'next/server';
  import { getAdminUser } from '@/lib/admin/auth';
  import { prisma } from '@/lib/db';

  export async function PUT(
    req: NextRequest,
    { params }: { params: { summaryId: string } },
  ) {
    if (!(await getAdminUser()))
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    try {
      const { content } = await req.json();
      const updatedSummary = await prisma.summary.update({
        where: { id: params.summaryId },
        data: { content },
      });
      return NextResponse.json(updatedSummary);
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to update summary' },
        { status: 500 },
      );
    }
  }
  ```

---

### 2. Admin Dashboard UI

- [ ] **Task 2.1: Scaffold Admin Pages and Layout:** Create the necessary page files and a protected layout for the admin section.

  - **Command:** `mkdir -p src/app/admin/dashboard src/app/admin/episodes/[episodeId]`
  - **File 1:** `src/app/admin/layout.tsx`
  - **Action 1:** Create the layout file that enforces admin-only access.

  ```tsx
  import { getAdminUser } from '@/lib/admin/auth';
  import { redirect } from 'next/navigation';

  export default async function AdminLayout({
    children,
  }: {
    children: React.ReactNode;
  }) {
    const adminUser = await getAdminUser();
    if (!adminUser) {
      redirect('/login?error=Admins only');
    }
    return <>{children}</>;
  }
  ```

  - **File 2:** `src/app/admin/dashboard/page.tsx`
  - **Action 2:** Create the main dashboard page file.

  ```tsx
  import { DraftsList } from '@/components/admin/drafts-list';

  export default function AdminDashboardPage() {
    return (
      <div className="container mx-auto p-4 md:p-8">
        <h1 className="text-3xl font-bold mb-6">Admin Dashboard</h1>
        <h2 className="text-2xl font-semibold mb-4">
          Content Drafts for Review
        </h2>
        <DraftsList />
      </div>
    );
  }
  ```

- [ ] **Task 2.2: Create `DraftsList` Component:** Build the component to fetch and display the list of draft episodes.

  - **Command:** `mkdir -p src/components/admin`
  - **File:** `src/components/admin/drafts-list.tsx`
  - **Action:** Create the component file.

  ```tsx
  'use client';

  import { useQuery } from '@tanstack/react-query';
  import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
  } from '@/components/ui/table';
  import { Button } from '@/components/ui/button';
  import Link from 'next/link';
  import { format } from 'date-fns';

  const fetchDrafts = async () => {
    const res = await fetch('/api/admin/drafts');
    if (!res.ok) throw new Error('Failed to fetch drafts');
    return res.json();
  };

  export function DraftsList() {
    const {
      data: drafts,
      isLoading,
      isError,
    } = useQuery({ queryKey: ['admin-drafts'], queryFn: fetchDrafts });

    if (isLoading) return <div>Loading drafts...</div>;
    if (isError)
      return <div className="text-red-500">Error loading drafts.</div>;

    return (
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Title</TableHead>
            <TableHead>Published At</TableHead>
            <TableHead>Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {drafts?.map((draft: any) => (
            <TableRow key={draft.id}>
              <TableCell>{draft.title}</TableCell>
              <TableCell>
                {format(new Date(draft.publishedAt), 'PPP')}
              </TableCell>
              <TableCell>
                <Button asChild>
                  <Link href={`/admin/episodes/${draft.id}`}>Review</Link>
                </Button>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    );
  }
  ```

- [ ] **Task 2.3: Create Curation Page and Editor Components:** Create the detailed editor page and the components it will use.

  - **File:** `src/app/admin/episodes/[episodeId]/page.tsx`
  - **Action:** Create the main curation page file.

  ```tsx
  import { prisma } from '@/lib/db';
  import { EpisodeEditor } from '@/components/admin/episode-editor';
  import { notFound } from 'next/navigation';

  async function getEpisodeData(episodeId: string) {
    const episode = await prisma.episode.findUnique({
      where: { id: episodeId },
      include: {
        summaries: true,
        protocols: true,
      },
    });
    return episode;
  }

  export default async function EpisodeCurationPage({
    params,
  }: {
    params: { episodeId: string };
  }) {
    const episode = await getEpisodeData(params.episodeId);

    if (!episode) {
      notFound();
    }

    return (
      <div className="container mx-auto p-4 md:p-8">
        <h1 className="text-3xl font-bold mb-6">Curation Console</h1>
        <EpisodeEditor episode={episode} />
      </div>
    );
  }
  ```

  - **File:** `src/components/admin/episode-editor.tsx`
  - **Action:** Create the dynamic, client-side editor component.

  ```tsx
  'use client';

  import { useForm, useFieldArray } from 'react-hook-form';
  import { useMutation, useQueryClient } from '@tanstack/react-query';
  import { useRouter } from 'next/navigation';
  import { Button } from '@/components/ui/button';
  import {
    Card,
    CardContent,
    CardHeader,
    CardTitle,
  } from '@/components/ui/card';
  import { Input } from '@/components/ui/input';
  import { Label } from '@/components/ui/label';
  import { Textarea } from '@/components/ui/textarea';
  import { Switch } from '@/components/ui/switch';

  // A generic update mutation function
  const updateApi = async ({ url, data }: { url: string; data: any }) => {
    const res = await fetch(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!res.ok) throw new Error(`Failed to update ${url}`);
    return res.json();
  };

  export function EpisodeEditor({ episode }: { episode: any }) {
    const router = useRouter();
    const queryClient = useQueryClient();
    const { register, control, handleSubmit, watch } = useForm({
      defaultValues: episode,
    });

    const { fields: protocolFields } = useFieldArray({
      control,
      name: 'protocols',
    });
    const { fields: summaryFields } = useFieldArray({
      control,
      name: 'summaries',
    });

    const updateMutation = useMutation({
      mutationFn: updateApi,
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['admin-drafts'] });
        alert('Update successful!');
      },
      onError: (error) => alert(error.message),
    });

    const handlePublish = () => {
      updateMutation.mutate(
        {
          url: `/api/admin/episodes/${episode.id}`,
          data: { status: 'PUBLISHED' },
        },
        {
          onSuccess: () => {
            alert('Episode Published!');
            router.push('/admin/dashboard');
          },
        },
      );
    };

    const onSubmit = (data: any) => {
      // Update episode
      updateMutation.mutate({
        url: `/api/admin/episodes/${episode.id}`,
        data: { title: data.title, description: data.description },
      });
      // Update summaries
      data.summaries.forEach((summary: any) =>
        updateMutation.mutate({
          url: `/api/admin/summaries/${summary.id}`,
          data: { content: summary.content },
        }),
      );
      // Update protocols
      data.protocols.forEach((protocol: any) =>
        updateMutation.mutate({
          url: `/api/admin/protocols/${protocol.id}`,
          data: protocol,
        }),
      );
    };

    return (
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-8">
        <Card>
          <CardHeader>
            <CardTitle>Episode Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label>Title</Label>
              <Input {...register('title')} />
            </div>
            <div>
              <Label>Description</Label>
              <Textarea {...register('description')} rows={5} />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Summaries</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {summaryFields.map((field, index) => (
              <div key={field.id}>
                <Label>Summary</Label>
                <Textarea
                  {...register(`summaries.${index}.content`)}
                  rows={8}
                />
              </div>
            ))}
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Protocols</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {protocolFields.map((field, index) => (
              <div key={field.id} className="p-4 border rounded-md space-y-4">
                <div>
                  <Label>Name</Label>
                  <Input {...register(`protocols.${index}.name`)} />
                </div>
                <div>
                  <Label>Category</Label>
                  <Input {...register(`protocols.${index}.category`)} />
                </div>
                <div>
                  <Label>Description</Label>
                  <Textarea {...register(`protocols.${index}.description`)} />
                </div>
                <div>
                  <Label>Implementation Guide</Label>
                  <Textarea
                    {...register(`protocols.${index}.implementationGuide`)}
                    rows={6}
                  />
                </div>
                <div className="flex items-center space-x-2">
                  <Switch
                    id={`isFree-${index}`}
                    {...register(`protocols.${index}.isFree`)}
                  />
                  <Label htmlFor={`isFree-${index}`}>Is Free?</Label>
                </div>
              </div>
            ))}
          </CardContent>
        </Card>

        <div className="flex justify-end gap-4">
          <Button type="submit" disabled={updateMutation.isPending}>
            {updateMutation.isPending ? 'Saving...' : 'Save Changes'}
          </Button>
          <Button
            type="button"
            variant="destructive"
            onClick={handlePublish}
            disabled={updateMutation.isPending}
          >
            Publish Episode
          </Button>
        </div>
      </form>
    );
  }
  ```

---

### 3. Manual Verification Steps

- [ ] **Task 3.1: Promote a User to Admin:** This is a manual database operation.

  - **Action:** Connect to your database (e.g., using `npx prisma studio`). Find your test user in the `User` table and change their `role` from `"USER"` to `"ADMIN"`. Save the change.

- [ ] **Task 3.2: Verify Admin Access:**
  - **Action:** Log in as the newly promoted admin user.
  - Navigate to `/admin/dashboard`. You should see the dashboard.
  - Log out. Navigate to `/admin/dashboard` again. You should be redirected to the login page. This confirms the security is working.
