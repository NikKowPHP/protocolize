Of course. Here is the detailed, atomic to-do list for Phase I, formatted as `phase-i-admin-content-curation-dashboard.md`.

This phase is dedicated to building the essential "human-in-the-loop" component of the content pipeline. It involves creating a secure admin area where AI-generated content can be reviewed, edited, and published. This ensures the quality and accuracy of the content before it reaches the end-users.

---

# **Phase I: Admin Content Curation Dashboard**

**Goal:** Develop the "human-in-the-loop" interface for the content pipeline. This involves building a secure admin dashboard where draft content generated by the AI can be reviewed, edited, and published to the live application.

**Prerequisite:** Phase H must be complete. The database contains draft episodes and protocols generated by the content ingestion pipeline.

---

### 1. Admin Area Scaffolding and Security

-   [ ] **Task 1.1: Add `role` to User Model:** Update the Prisma schema to include an `admin` role for users.
    *   **File:** `prisma/schema.prisma`
    *   **Action:** Add a `role` field to the `User` model.
    ```prisma
    model User {
      // ... existing fields
      role           String    @default("USER") // Add this line (USER, ADMIN)
    }
    ```

-   [ ] **Task 1.2: Create and Apply Role Migration:** Generate and apply a new migration for the schema change.
    ```bash
    npx prisma migrate dev --name add-user-role
    ```

-   [ ] **Task 1.3: Create Admin Layout:** Create a new route group and layout for the admin section. This layout will contain the middleware logic to protect all admin routes.
    *   **Command:** `mkdir -p src/app/admin`
    *   **File:** `src/app/admin/layout.tsx`
    *   **Action:** Create the file with the following content.
    ```tsx
    import { createClient } from '@/lib/supabase/server';
    import { prisma } from '@/lib/db';
    import { notFound } from 'next/navigation';
    import Link from 'next/link';

    async function checkAdmin() {
      const supabase = await createClient();
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        return false;
      }

      const dbUser = await prisma.user.findUnique({
        where: { id: user.id },
        select: { role: true },
      });

      return dbUser?.role === 'ADMIN';
    }

    export default async function AdminLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const isAdmin = await checkAdmin();

      if (!isAdmin) {
        notFound();
      }

      return (
        <div className="flex min-h-screen">
          <nav className="w-64 bg-gray-800 text-white p-4">
            <h2 className="text-xl font-bold mb-6">Admin Panel</h2>
            <ul>
              <li><Link href="/admin/dashboard" className="block py-2 hover:bg-gray-700 rounded">Dashboard</Link></li>
              {/* More admin links can be added here */}
            </ul>
          </nav>
          <main className="flex-1 p-8 bg-gray-100 dark:bg-gray-900">
            {children}
          </main>
        </div>
      );
    }
    ```

-   [ ] **Task 1.4: Create Admin Dashboard Page:** Create the main landing page for the admin section.
    *   **File:** `src/app/admin/dashboard/page.tsx`
    *   **Action:** Create the file with the following content.
    ```tsx
    import { prisma } from '@/lib/db';
    import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
    import Link from 'next/link';

    export default async function AdminDashboardPage() {
      const draftCount = await prisma.episode.count({ where: { status: 'DRAFT' } });
      const publishedCount = await prisma.episode.count({ where: { status: 'PUBLISHED' } });

      return (
        <div>
          <h1 className="text-3xl font-bold mb-6">Admin Dashboard</h1>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <Card>
              <CardHeader>
                <CardTitle>Draft Episodes</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-4xl font-bold">{draftCount}</p>
                <Link href="/admin/drafts" className="text-sm text-blue-500 hover:underline">Review Drafts</Link>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle>Published Episodes</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-4xl font-bold">{publishedCount}</p>
              </CardContent>
            </Card>
          </div>
        </div>
      );
    }
    ```

### 2. Draft Review and Publishing UI

-   [ ] **Task 2.1: Create Drafts List Page:** Create a page that lists all episodes with a "DRAFT" status.
    *   **Command:** `mkdir -p src/app/admin/drafts`
    *   **File:** `src/app/admin/drafts/page.tsx`
    *   **Action:** Create the file to fetch and display draft episodes.
    ```tsx
    import { prisma } from '@/lib/db';
    import Link from 'next/link';
    import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
    import { Button } from '@/components/ui/button';

    export default async function DraftsPage() {
      const drafts = await prisma.episode.findMany({
        where: { status: 'DRAFT' },
        orderBy: { publishedAt: 'desc' },
      });

      return (
        <div>
          <h1 className="text-3xl font-bold mb-6">Draft Episodes for Review</h1>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Title</TableHead>
                <TableHead>Published Date</TableHead>
                <TableHead>Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {drafts.map(draft => (
                <TableRow key={draft.id}>
                  <TableCell>{draft.title}</TableCell>
                  <TableCell>{draft.publishedAt?.toLocaleDateString()}</TableCell>
                  <TableCell>
                    <Button asChild>
                      <Link href={`/admin/drafts/${draft.id}`}>Review & Edit</Link>
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      );
    }
    ```

-   [ ] **Task 2.2: Create `EpisodeEditorForm` Component:** Create a client component to handle the editing of a draft episode and its protocols.
    *   **File:** `src/components/admin/episode-editor-form.tsx`
    *   **Action:** Create a form that takes the full episode data (including protocols) and allows an admin to edit all fields.
    ```tsx
    "use client";

    import { Button } from "@/components/ui/button";
    import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
    import { Input } from "@/components/ui/input";
    import { Label } from "@/components/ui/label";
    import { Textarea } from "@/components/ui/textarea";
    import { useForm, useFieldArray } from "react-hook-form";
    // Define types based on Prisma models
    type Protocol = { id: string; name: string; description: string; implementationGuide: string; category: string; };
    type Episode = { id: string; title: string; description: string | null; protocols: Protocol[]; };

    interface EpisodeEditorFormProps {
      episode: Episode;
    }

    export default function EpisodeEditorForm({ episode }: EpisodeEditorFormProps) {
      const { register, control, handleSubmit } = useForm({
        defaultValues: episode,
      });
      const { fields } = useFieldArray({
        control,
        name: "protocols",
      });

      const onSave = (data: any) => {
        // API call to save changes will be here
        console.log("Saving data:", data);
        alert("Changes saved! (console log only)");
      };

      const onPublish = (data: any) => {
        // API call to publish will be here
        console.log("Publishing episode:", data);
        alert("Episode published! (console log only)");
      }

      return (
        <form onSubmit={handleSubmit(onSave)}>
          <Card>
            <CardHeader>
              <CardTitle>Edit Episode: {episode.title}</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label htmlFor="title">Episode Title</Label>
                <Input id="title" {...register("title")} />
              </div>
              <div>
                <Label htmlFor="description">Episode Description</Label>
                <Textarea id="description" {...register("description")} rows={5} />
              </div>
            </CardContent>
          </Card>

          <h2 className="text-2xl font-bold my-6">Protocols</h2>
          <div className="space-y-6">
            {fields.map((field, index) => (
              <Card key={field.id}>
                <CardHeader>
                  <CardTitle>Edit Protocol</CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <Input type="hidden" {...register(`protocols.${index}.id`)} />
                  <div>
                    <Label>Protocol Name</Label>
                    <Input {...register(`protocols.${index}.name`)} />
                  </div>
                  <div>
                    <Label>Category</Label>
                    <Input {...register(`protocols.${index}.category`)} />
                  </div>
                  <div>
                    <Label>Description</Label>
                    <Textarea {...register(`protocols.${index}.description`)} rows={4} />
                  </div>
                  <div>
                    <Label>Implementation Guide</Label>
                    <Textarea {...register(`protocols.${index}.implementationGuide`)} rows={6} />
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          
          <div className="mt-8 flex gap-4">
            <Button type="submit">Save Draft</Button>
            <Button variant="destructive" onClick={handleSubmit(onPublish)}>Save & Publish</Button>
          </div>
        </form>
      );
    }
    ```

-   [ ] **Task 2.3: Create Dynamic Draft Edit Page:** Create the page that uses the `EpisodeEditorForm` to edit a specific draft.
    *   **Command:** `mkdir -p src/app/admin/drafts/[episodeId]`
    *   **File:** `src/app/admin/drafts/[episodeId]/page.tsx`
    *   **Action:** Create a server component that fetches the full draft episode data and passes it to the client component form.
    ```tsx
    import { prisma } from '@/lib/db';
    import { notFound } from 'next/navigation';
    import EpisodeEditorForm from '@/components/admin/episode-editor-form';

    async function getDraftEpisode(episodeId: string) {
      const episode = await prisma.episode.findUnique({
        where: { id: episodeId, status: 'DRAFT' },
        include: {
          protocols: true,
        },
      });
      return episode;
    }

    export default async function EditDraftPage({ params }: { params: { episodeId: string } }) {
      const episode = await getDraftEpisode(params.episodeId);

      if (!episode) {
        notFound();
      }

      return (
        <div>
          <EpisodeEditorForm episode={episode} />
        </div>
      );
    }
    ```

### 3. Admin Publishing API

-   [ ] **Task 3.1: Create Admin API Route for Publishing:** Create the API endpoint that will handle the logic for updating and publishing content.
    *   **Command:** `mkdir -p src/app/api/admin/episodes/[episodeId]`
    *   **File:** `src/app/api/admin/episodes/[episodeId]/route.ts`
    *   **Action:** Implement a `PUT` handler that updates an episode and its protocols. It should include an optional query parameter to trigger publishing.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createClient } from '@/lib/supabase/server';
    import { prisma } from '@/lib/db';

    // Admin role check middleware would be ideal here in a real app
    async function checkAdmin(userId: string) {
        const user = await prisma.user.findUnique({ where: { id: userId }});
        return user?.role === 'ADMIN';
    }

    export async function PUT(req: NextRequest, { params }: { params: { episodeId: string } }) {
      const supabase = await createClient();
      const { data: { user } } = await supabase.auth.getUser();

      if (!user || !(await checkAdmin(user.id))) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }
      
      const { searchParams } = new URL(req.url);
      const shouldPublish = searchParams.get('publish') === 'true';

      try {
        const body = await req.json();
        const { title, description, protocols } = body;

        const transaction = [
          prisma.episode.update({
            where: { id: params.episodeId },
            data: {
              title,
              description,
              status: shouldPublish ? 'PUBLISHED' : 'DRAFT',
            },
          }),
          ...protocols.map((p: any) => 
            prisma.protocol.update({
              where: { id: p.id },
              data: {
                name: p.name,
                category: p.category,
                description: p.description,
                implementationGuide: p.implementationGuide,
                status: shouldPublish ? 'PUBLISHED' : 'DRAFT',
              },
            })
          ),
        ];

        await prisma.$transaction(transaction);

        return NextResponse.json({ message: `Episode ${shouldPublish ? 'published' : 'saved'} successfully.` });
      } catch (error) {
        console.error('Failed to update episode:', error);
        return NextResponse.json({ error: 'Failed to update episode' }, { status: 500 });
      }
    }
    ```

-   [ ] **Task 3.2: Connect `EpisodeEditorForm` to the API:** Update the form to make live API calls.
    *   **File:** `src/components/admin/episode-editor-form.tsx`
    *   **Action:** Use `fetch` to call the new `/api/admin/episodes/...` endpoint in the `onSave` and `onPublish` functions.
    ```tsx
    // In src/components/admin/episode-editor-form.tsx

    // Replace the onSave function
    const onSave = async (data: any) => {
      try {
        const res = await fetch(`/api/admin/episodes/${episode.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        if (!res.ok) throw new Error('Failed to save draft');
        alert('Draft saved successfully!');
      } catch (error) {
        alert('Error saving draft.');
        console.error(error);
      }
    };

    // Replace the onPublish function
    const onPublish = async (data: any) => {
      if (!confirm('Are you sure you want to publish this episode and all its protocols?')) return;
      try {
        const res = await fetch(`/api/admin/episodes/${episode.id}?publish=true`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        if (!res.ok) throw new Error('Failed to publish');
        alert('Episode published successfully!');
        // Ideally, redirect to the drafts page after publishing
        window.location.href = '/admin/drafts';
      } catch (error) {
        alert('Error publishing episode.');
        console.error(error);
      }
    };
    ```